name: Semantic Versioning

on:
  push:
    branches:
      - main
      - dev

jobs:
  versioning:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - run: git fetch --tags

      # Ãšltima tag existente
      - name: Get latest tag
        run: |
          TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=$TAG" >> $GITHUB_ENV

      # Config Git
      - name: Git config
        run: |
          git config user.email "actions@github.com"
          git config user.name "GitHub Actions"

      # ðŸ”¥ REPLAY REAL DE VERSÃ•ES
      - name: Replay versions per commit
        run: |
          CURRENT_TAG=${{ env.latest_tag }}
          VERSION=${CURRENT_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          echo "Starting from $CURRENT_TAG"

          git log --reverse --pretty="%H|%s" $CURRENT_TAG..HEAD > commits.txt

          CREATED_TAGS=0

          while IFS='|' read -r SHA MSG; do
            NEW_VERSION=""

            if [[ "$MSG" == *"BREAKING CHANGE"* ]]; then
              MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0
              NEW_VERSION="v$MAJOR.$MINOR.$PATCH"

            elif [[ "$MSG" =~ ^feat(\(.+\))?: ]]; then
              MINOR=$((MINOR+1)); PATCH=0
              NEW_VERSION="v$MAJOR.$MINOR.$PATCH"

            elif [[ "$MSG" =~ ^(fix|docs|style|test|ci)(\(.+\))?: ]]; then
              PATCH=$((PATCH+1))
              NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
            fi

            if [ -n "$NEW_VERSION" ]; then
              if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
                echo "Tag $NEW_VERSION already exists"
              else
                echo "Tagging $SHA as $NEW_VERSION"
                git tag "$NEW_VERSION" "$SHA"
                CREATED_TAGS=1
              fi
            fi

          done < commits.txt

          git push origin --tags

          FINAL_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "new_version=$FINAL_VERSION" >> $GITHUB_ENV
          echo "created_tags=$CREATED_TAGS" >> $GITHUB_ENV

      # Se nÃ£o houve novas versÃµes, parar
      - name: Stop if nothing changed
        if: env.created_tags == '0'
        run: echo "No versionable commits found."

      # Atualizar package.json e package-lock.json
      - name: Update package.json files
        if: env.created_tags == '1'
        run: |
          VERSION=${{ env.new_version }}
          VERSION=${VERSION#v}

          FILES=$(find . -name package.json)

          if [ -z "$FILES" ]; then
            echo "No package.json found."
            exit 0
          fi

          sudo apt-get update && sudo apt-get install -y jq npm

          for FILE in $FILES; do
            echo "Updating $FILE to $VERSION"
            jq ".version=\"$VERSION\"" "$FILE" > tmp.json && mv tmp.json "$FILE"
            git add "$FILE"

            DIR=$(dirname "$FILE")
            cd "$DIR"
            npm install --package-lock-only
            git add package-lock.json
            cd - > /dev/null
          done

      # CHANGELOG + RELEASE NOTES
      - name: Update changelog
        if: env.created_tags == '1'
        run: |
          DATE=$(date +'%Y-%m-%d')
          VERSION=${{ env.new_version }}

          touch CHANGELOG.md RELEASE_NOTES.md
          LOG=$(git log --pretty=format:"* %s" ${{ env.latest_tag }}..HEAD)

          echo "## $VERSION - $DATE" > tmp1.md
          echo "$LOG" >> tmp1.md
          cat CHANGELOG.md >> tmp1.md
          mv tmp1.md CHANGELOG.md

          echo "## $VERSION - $DATE" > tmp2.md
          echo "$LOG" >> tmp2.md
          cat RELEASE_NOTES.md >> tmp2.md
          mv tmp2.md RELEASE_NOTES.md

          git add CHANGELOG.md RELEASE_NOTES.md

      # Commit automÃ¡tico
      - name: Commit release updates
        if: env.created_tags == '1'
        run: |
          git diff --cached --quiet || git commit -m "chore(release): ${{ env.new_version }}"
          git push origin HEAD
